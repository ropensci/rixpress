---
title: "Organizing Large Projects with Sub-Pipelines"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{sub-pipelines}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)

# Detect if Nix is available
nix_available <- tryCatch(
  {
    result <- system2("nix", "--version", stdout = TRUE, stderr = TRUE)
    length(result) > 0 && !inherits(result, "try-error")
  },
  error = function(e) FALSE,
  warning = function(w) FALSE
)

# Also check if we're in a Nix shell with rixpress available
rixpress_available <- nix_available && requireNamespace("rixpress", quietly = TRUE)

# Set up a temporary directory for the demo if we can run it
if (rixpress_available) {
  demo_dir <- tempfile("subpipelines_vignette_")
  dir.create(demo_dir, recursive = TRUE)
  original_wd <- getwd()
}
```

This vignette introduces `rxp_pipeline()`, a function for organizing large
projects into logical sub-pipelines. This feature is particularly useful when
working on complex projects with multiple phases (e.g., ETL, Modeling, Reporting)
or when collaborating in teams where different members work on different parts
of the pipeline.

```{r show-nix-status, echo = FALSE, results = "asis"}
if (!nix_available) {
  cat(
    "> **Note:** Nix is not available on this system, so code chunks ",
    "are shown but not evaluated. To run these examples, install Nix and ",
    "execute this vignette inside a Nix shell with rixpress available.\n\n"
  )
}
```

## The Problem: Large Pipelines Become Unwieldy

As pipelines grow, a single `gen-pipeline.R` file can become difficult to
manage. Consider a data science project with:
- Data extraction and cleaning (ETL)
- Feature engineering
- Model training
- Model evaluation
- Report generation

Putting all derivations in one file makes it hard to:

- Navigate the code
- Understand which derivations belong to which phase
- Collaborate across team members
- Reuse pipeline components in other projects

## The Solution: rxp_pipeline()

`rxp_pipeline()` allows you to:

1. **Organize** derivations into named groups
2. **Color-code** groups for visual distinction in DAG visualizations
3. **Modularize** your code across multiple R scripts

### Basic Usage

```{r basic-usage, eval = rixpress_available}
library(rixpress)

# Create derivations
d1 <- rxp_r(name = raw_data, expr = mtcars)
d2 <- rxp_r(name = clean_data, expr = dplyr::filter(raw_data, am == 1))

# Wrap in a named pipeline with a color
pipe <- rxp_pipeline(
  name = "Data Preparation",
  derivs = list(d1, d2),
  color = "#E69F00"
)

# View the pipeline object
print(pipe)
```

```{r basic-usage-fallback, eval = !rixpress_available, echo = FALSE}
cat('rixpress pipeline: Data Preparation
  Color: #E69F00
  Derivations: 2
    - raw_data
    - clean_data')
```

The `rxp_pipeline()` function takes:

- **name**: A descriptive name for this group of derivations
- **derivs**: A list of derivation objects (from `rxp_r()`, `rxp_py()`, etc.)
- **color**: Optional CSS color name or hex code for DAG visualization

### Combining Multiple Pipelines

Multiple pipelines are simply passed as a list to `rxp_populate()`:

```{r combining-pipelines, eval = FALSE}
# Define two pipelines
pipe_etl <- rxp_pipeline("ETL", list(d1, d2), color = "darkorange")
pipe_model <- rxp_pipeline("Model", list(d3, d4), color = "dodgerblue")

# Build combined pipeline
rxp_populate(list(pipe_etl, pipe_model))
```

## The Master Script Pattern

For larger projects, we recommend the **Master Script Pattern**: define each
sub-pipeline in a separate R file, then combine them in a master script.

### Project Structure

```
my-project/
├── default.nix           # Nix environment (generated by rix)
├── gen-env.R             # Script to generate default.nix
├── gen-pipeline.R        # MASTER SCRIPT: combines all sub-pipelines
└── pipelines/
    ├── 01_data_prep.R    # Data preparation sub-pipeline
    ├── 02_analysis.R     # Analysis sub-pipeline
    └── 03_reporting.R    # Reporting sub-pipeline
```

### Sub-Pipeline Files

Each sub-pipeline file returns a list of derivations:

**pipelines/01_data_prep.R**
```{r sub-pipeline-1, eval = FALSE}
# Data Preparation Sub-Pipeline
library(rixpress)

list(
  rxp_r(name = raw_mtcars, expr = mtcars),
  rxp_r(name = clean_mtcars, expr = dplyr::filter(raw_mtcars, am == 1)),
  rxp_r(name = selected_mtcars, expr = dplyr::select(clean_mtcars, mpg, cyl, hp, wt))
)
```

**pipelines/02_analysis.R**
```{r sub-pipeline-2, eval = FALSE}
# Analysis Sub-Pipeline
library(rixpress)

list(
  rxp_r(name = summary_stats, expr = summary(selected_mtcars)),
  rxp_r(name = mpg_model, expr = lm(mpg ~ hp + wt, data = selected_mtcars)),
  rxp_r(name = model_coefs, expr = coef(mpg_model))
)
```

### Master Script

**gen-pipeline.R**
```{r master-script, eval = FALSE}
library(rixpress)

# Source sub-pipelines
data_prep <- source("pipelines/01_data_prep.R")$value
analysis <- source("pipelines/02_analysis.R")$value

# Create named pipelines with colors
pipe_data_prep <- rxp_pipeline("Data Preparation", data_prep, color = "#E69F00")
pipe_analysis <- rxp_pipeline("Statistical Analysis", analysis, color = "#56B4E9")

# Build combined pipeline
rxp_populate(list(pipe_data_prep, pipe_analysis), project_path = ".", build = FALSE)
rxp_dag_for_ci()
```

## Live Demo: Creating Sub-Pipelines

Let's demonstrate the full workflow in a temporary directory:

```{r live-demo-setup, eval = rixpress_available, echo = TRUE}
# Set up demo in temporary directory
setwd(demo_dir)

# Create a minimal default.nix for the demo
# (In real usage, you would use rix::rix() to generate this)
writeLines('
let
 pkgs = import (fetchTarball "https://github.com/rstats-on-nix/nixpkgs/archive/r-daily.tar.gz") {};
 rpkgs = builtins.attrValues { inherit (pkgs.rPackages) dplyr; };
 system_packages = builtins.attrValues { inherit (pkgs) R; };
in
pkgs.mkShell {
  buildInputs = [ rpkgs system_packages ];
}
', "default.nix")

library(rixpress)
```

```{r live-demo-pipelines, eval = rixpress_available, echo = TRUE}
# Define Sub-Pipeline 1: Data Preparation
data_prep_derivs <- list(
  rxp_r(name = raw_data, expr = mtcars),
  rxp_r(name = filtered_data, expr = dplyr::filter(raw_data, am == 1)),
  rxp_r(name = selected_data, expr = dplyr::select(filtered_data, mpg, hp, wt))
)

# Define Sub-Pipeline 2: Analysis
analysis_derivs <- list(
  rxp_r(name = summary_stats, expr = summary(selected_data)),
  rxp_r(name = linear_model, expr = lm(mpg ~ hp + wt, data = selected_data)),
  rxp_r(name = coefficients, expr = coef(linear_model))
)

# Wrap in Named Pipelines
pipe_prep <- rxp_pipeline("Data Prep", data_prep_derivs, color = "#E69F00")
pipe_analysis <- rxp_pipeline("Analysis", analysis_derivs, color = "#56B4E9")

# Show the pipelines
print(pipe_prep)
print(pipe_analysis)
```

```{r live-demo-populate, eval = rixpress_available, echo = TRUE}
# Build the Combined Pipeline (without actually running nix-build)
rxp_populate(list(pipe_prep, pipe_analysis), project_path = ".", build = FALSE)

# Check the generated dag.json for pipeline metadata
dag_content <- jsonlite::fromJSON("_rixpress/dag.json")
dag_content$derivations[, c("deriv_name", "pipeline_group", "pipeline_color")]
```

```{r live-demo-fallback, eval = !rixpress_available, echo = FALSE}
cat('  deriv_name pipeline_group pipeline_color
1     raw_data     Data Prep       #E69F00
2 filtered_data     Data Prep       #E69F00
3 selected_data     Data Prep       #E69F00
4 summary_stats       Analysis       #56B4E9
5  linear_model       Analysis       #56B4E9
6  coefficients       Analysis       #56B4E9')
```

## Visualizing Sub-Pipelines

When sub-pipelines are defined, the DAG visualization functions automatically
use pipeline groups for coloring:

```{r visualization, eval = FALSE}
# Interactive visualization with pipeline colors
rxp_visnetwork()

# Static ggplot visualization with pipeline colors
rxp_ggdag()
```

The legend will show your pipeline names ("Data Prep", "Analysis") instead of
derivation types.

### Switching Between Color Modes

```{r color-modes, eval = FALSE}
# Color by pipeline group (default when pipelines are defined)
rxp_visnetwork(color_by = "pipeline")

# Color by derivation type (rxp_r, rxp_py, etc.) - original behavior
rxp_visnetwork(color_by = "type")
```

## How It Works Internally

When you call `rxp_populate()` with `rxp_pipeline` objects:

1. **Flattening**: Pipelines are flattened to a single list of derivations
2. **Metadata Preservation**: Each derivation retains `pipeline_group` and `pipeline_color`
3. **DAG Generation**: `dag.json` includes pipeline metadata
4. **Visualization**: `rxp_visnetwork()` and `rxp_ggdag()` read this metadata

## Backward Compatibility

If you don't use `rxp_pipeline()`, everything works exactly as before:

```{r backward-compat, eval = FALSE}
# This still works - derivations get "default" as their pipeline group
list(
  rxp_r(name = a, expr = 1),
  rxp_r(name = b, expr = a + 1)
) |> rxp_populate()
```

## Best Practices

1. **Use descriptive pipeline names**: "Data Preparation" is better than "ETL"
2. **Choose contrasting colors**: Use [ColorBrewer](https://colorbrewer2.org/) palettes
3. **Keep sub-pipelines focused**: One logical phase per sub-pipeline
4. **Order your files**: Use numeric prefixes (01_, 02_, etc.)
5. **Document dependencies**: Note which sub-pipelines depend on others

## Conclusion

`rxp_pipeline()` provides a simple yet powerful way to organize complex
pipelines. By grouping derivations into logical units, you can:

- Keep your code organized and maintainable
- Enable team collaboration on different parts of the pipeline
- Visualize the structure of your workflow with meaningful colors
- Reuse sub-pipelines across projects

For a working example, see the `subpipelines` demo in the
[rixpress_demos](https://github.com/b-rodrigues/rixpress_demos) repository.

```{r cleanup, include = FALSE}
# Clean up: restore working directory and remove temp files
if (rixpress_available) {
  setwd(original_wd)
  unlink(demo_dir, recursive = TRUE)
}
```
